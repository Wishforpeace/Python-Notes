[TOC]



# 计算思维复习

## 1.计算思维

### 计算机的概念

计算机是==数据处理模型==

> 它根据事先存储在存储器中的一组指令的要求，接收输入的数据、处理输入的数据、 并且输出数据处理结果。

数学家**冯·诺依曼**最早提出计算机制造的**冯·诺依曼模型**

+ 采用二进制逻辑
+ 程序存储执行
+ 计算机核心组件
  + ==运算器==
  + ==控制器==
  + ==存储器==

### 计算机硬件

计算机系统中由电子、机械和光电元件等组成的各种物理装置的总称

+ CPU
+ 主板
+ 内存条
+ 各种输入输出设备
  + 键盘
  + 鼠标

### 数据

计算机处理数据仅包含0和1，将各种信息转换都需要转换成0和1，这个过程叫==编码==

### 计算机软件

+ 系统软件
+ 应用软件

### 计算思维实例

#### 阿基米德的割圆术

#### 刘徽的割圆术

### 计算机的发展历史

+ **帕斯卡**
+ **莱布尼兹**
+ Charles Babbage(1792-1871)
  + Difference  Engine & Analytical Engine

+ Jacquard Loom

  + **提花织机**（Jacquard Loom）

  + > 它利用穿孔卡片（类似于存储程序）来控制织布过程中经线的提升。

+ Herman Hollerith ==美国信息处理之父==
  + 卡片制表机（Tabulating Machine）

### 早期电子计算机

#### Colossus（巨人计算机）

**阿兰**·**图灵**

1936年发表的论文，提出计算机抽象模型

1943年，设计了Colossus，主要用于破解德国密码

#### ENIAC

第一台电子计算机ENIAC诞生于1946年，由==莫奇利与埃克特设计==

编程通过插孔和开关实现，计算速度为5000次/秒，占地1000平方英尺

### 现代计算机的诞生

**第一代计算机（大约1950-1959年）

主要特征：
采用真空电子管作为主要元器件 
只有专家才会使用
主要用于商用，体积大价格贵，只有大机构才能负担得起。
典型代表：
EDVAC（Electronic Discrete variable Automatic Computer）
第一台使用二进制系统的计算机，诞生于 1949年。
EDSAC（Electronic Delay Storage Automatic Calculator）
第一台基于冯.诺伊曼模型(存储程序)的计算机，诞生于 1950年。
UNIVAC (Universal Automatic Computer) 
第一台商业计算机，诞生于 1951年。

**第二代计算机（大约1959-1965年）**

主要特征：
采用晶体管作为主要元器件 
与第一代相比体积变小
高级程序设计语言的出现使得编程变得容易
成本下降中小企业也能负担得起
典型代表：
PDP-1
CDC6600 

**第三代计算机（大约1965-1975年）**

主要特征：
采用集成电路作为主要元器件 
小型计算机面向市场
软件业开始产生
成本进一步下降
典型代表：
Cray-1
PDP-8 &11
IBM360

**第四代计算机（大约1975-1985年）**

主要特征：
采用超大规模集成电路作为主要元器件 
微型计算机问世并步入家庭
开始研究计算机网络
成本进一步下降
典型代表：
Apple I
Apple II

**第五代计算机（大约1985-现在）**

主要特征：
个人电脑以及掌上电脑出现
多媒体技术以及虚拟现实得到广泛应用
输入输出设备更加多样化
……

## 2.定位数系

### 数系分类

+ 简单分群数系

  + > 简单分群数系的记载出现在人类早期文明的遗迹中，古埃及人、古巴比伦人、古希腊雅典人以及古罗马人就是使用的简单分群数系。
    > 古埃及人与古巴比伦人使用的都是象形文字，古埃及人使用形似一根竖线的符号|表示单个数量，这和其他一些文明中表示单个数量的数字符号不谋而合，比如前面提到的古罗马人使用字母I表示单个数量，中国古代大约是春秋战国时期开始作为计算工具使用的算筹，就是用一根小木棍表示单个数量。 

+ 乘法分群数系

  + > 可以对简单分群数系在数的表示上做些改进，对十以内的九个自然数（没有零）分别使用不同的单个符号表示，而不是只使用一个符号|，使用阿拉伯数字1-9表示十以内的自然数。 
    > A、B、C等表示更大自然数的符号依然保留，对应不同自然数的符号只出现一次，而不是像简单分群数系里面那样会出现多个相同符号罗列的情况，比如简单分群数系表示的数BBAAA||||使用乘法分群数系表示为2B3A4，每个大写英文字母前面的数字表示该字母的个数。

+ 定位数系

  + > 定位数系可以看做是在乘法分群数系的基础上再次改进，以乘法分群数系表示的自然数3B2A5为例，数字3表示B的个数，数字2表示A的个数，而且从小到大的数量单位1、A、B、C等都是按照从右到左的顺序排列，何不干脆将数量单位去掉，数量单位前面的数字采取固定位置摆放。
    >
    >具体来说右边第一位对应十以内数字（也就是数量单位1的个数），右边第二位固定为数量单位A的个数，右边第三位固定为数量单位B的个数，以此类推。
    >因此乘法分群数系表示的自然数3B2A5 ，转换为定位数系可表示为325，表示该数包含3个B、2个A和5个1。

### 二进制

### 八进制

### 十六进制

## 3.数据存储

>数据由一种格式转变成另一种格式的过程被称为==编码（encoding）==，使用阿拉伯数字表示的数与使用罗马数字表示的数，就是针对数值型数据的两种不同的编码形式。
>构成计算机存储系统最基本的物理元器件通常只有两种状态，使用这两种状态模拟数据的表示，最简单直接的方法就是将一种状态表示 0，另一种状态表示 1，多个物理元器件的排列就可以表示 0 和 1 组成的数字串，所以计算机存储设备可以存储的信息是 0 和 1 组成的数字串信息。
>计算机存储的信息中，单个数字 0 或 1 被称为位（binary digit，英文缩写bit），因为bit可读作比特，所以binary digit有时也被称为比特位，多个比特位组成的数字串被称为位模式（bit pattern），==8个比特位构成的位模式被称为字节（byte）==。

### 数值型数据在计算机中的存储

#### 整数的存储

+ ##### 无符号表示法

  + 存储到计算机中的整数，最简单的一种编码方式就是将该整数转换成二进制形式，不过**这种方法不能区分具有相同绝对值的正负整数**，也就是说这种编码形式适合于保存非负整数，因此这种编码方式也称为无符号表示法（unsigned representation）。

  + 将一个整数按照无符号表示法编码成n位位模式的方法是：将该数转换成二进制形式，若转换后数位不足n位，则在该数的左边补0凑足n位。
    反过来将一个使用n位无符号表示法表示的位模式还原为整数（解码）的方法是：将位模式最左边开始的连续若干个0舍去，然后将剩余的位模式（当做二进制整数）转换为十进制整数。
  + n位位模式可以有2n种不同的排列，共可以表示2n个非负整数，从小到大排列为0到2n−1，所以使用n位无符号表示法可以表示的最小整数是0，可以表示的最大整数是2n−1。
  + 大于2n−1的整数转换为二进制整数时数位会超出n位，此时选取最右边的n位位模式作为编码信息，那么左边若干位会被舍去，再反过来解码后得到的整数并不是原来的整数，这种因为超出存储限制导致的编码错误被称为==溢出（overflow）==。

+ 符号加绝对值表示法

  + 只能存储非负整数的计算机系统显然是功能不完整的，为了解决负整数的编码问题，可以考虑将符号位引入到编码后的位模式，也就是说将最左边的一位作为符号位，0表示非负整数，1表示负整数，其余的位模式作为存储这个数绝对值的数据位，这种编码方法被称为符号加绝对值表示法（sign-and-magnitude representation）。

    > 比如整数-7，如果还是用8位位模式来编码，就将编码后最左边的一位作为符号位，用1表示；然后将-7的绝对值7转换成二进制形式(111)2，除去最左边的符号位，还有7位用于保存(111)2，于是将111左边补4个0凑足7位得到0000111；再加上最左边的符号位1，最终-7的编码形式是==10000111== 。对于整数7，其编码后的形式是00000111。 

+ 二进制补码表示法
  + 修复方案1直接在符号加绝对值表示法的基础上仅仅修改一个位模式1000对应的整数，将其由原来对应的-0改为-8；
  + 修复方案2在修复方案1的基础上对1开头的位模式对应的整数在排序上做了个反序调整。（应用最广）

#### 小数的存储

##### （1）二进制数的规范化形式

二进制数的规范化形式是将二进制数表示成“==$\pm a.xx…x\times2^n$==”的形式（其中a是数字1，n是整数）。二进制小数变成规范化形式后由符号位（负还是非负）、小数（$a.xx\ldots x$）和指数（$2^n$）这三部分组成。
二进制小数的存储涉及到这三部分的分别存储。符号位的存储需要保存的是该数“非负”还是“负”，所以仅需占用1个比特位足以；小数部分仅需要存储小数点后面的数字；指数部分仅需要存储指数n即可。指数n尽管是整数，但是存储指数采用的编码并不是二进制补码，而是余码。

##### （2）余码表示法

通过将原本大体上“**正负各半**”的整数集通过全体成员**加上一个固定的正整数后，变成非负整数集**，然后再转换成**二进制数进行编码**的方法就是余码表示法（excess representation）。
**余码表示法中被加入的正整数被称为==偏移量==**，编码位数不同，要表示的整数范围不同，使用的偏移量就不同。同样是4位编码长度，如果要使用余码表示法编码整数-7到8，则使用的偏移量是7。可以用符号`excess_k`表示偏移量为k的余码表示法。
比如-3使用4位`excess_7`编码的过程为：先将-3加上7得到4，然后将4转成二进制数得到100，左边补1个0得到最终编码形式0100。
再比如3使用4位excess_7编码的过程也是先将3加上7得到10，然后将10转成二进制数得到1010，这就是最终的编码形式。

##### （3）浮点表示法

计算机存储小数的方法是将该数使用规范化表示后，**存储符号、尾数（小数点后面的数字）、指数**这三部分信息，这种存储方法被称为**浮点表示法（floating-point representation）**。
浮点表示法的格式遵循美国电气和电子工程师协会（Institute of Electrical and Electronics Engineers，英文缩写为IEEE）提出的两种标准：一种是单精度（single）表示法，使用32位位模式；另一种是双精度（double）表示法，使用64位位模式。

![](https://github.com/Wishforpeace/Typora/blob/main/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

#### 其他多媒体数据在计算机中的存储

##### 文本的存储

###### ASCII

美国国家标准学会（American National Standards Institute，ANSI）在1967年发布了美国信息交换标准代码（American Standard Code for Information Interchange，ASCII），**==它包含了128个字符==**，编码方式很简单，给每个字符分配一个十进制自然数编号，**从0开始到127为止，然后将这些自然数编号转换成二进制形式，即为每个字符对应的ASCII码。**理论上来说存储这128个字符只需要7位即可，但是在计算机系统中约定了==8个比特位（也就是1个字节）==是存储数据的最小单位，所以ASCII中的每个字符也占据==1个字节==的存储容量。ASCII中的这128个字符里面包含全体英文字母的大小写，0-9的数字，还有一些基本的标点符号以及数学运算符号，编码的二进制形式都是0开头。****

| **编码** | **字符** | **编码** | **字符** | **编码** | **字符** | **编码** | **字符** | **编码** | **字符** | **编码** | **字符** | **编码** | **字符** | **编码** | **字符** |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| **0**    | NUL      | 16       | DLE      | 32       | SPC      | 48       | 0        | 64       | @        | 80       | P        | 96       | `        | 112      | p        |
| **1**    | SOH      | 17       | DC1      | 33       | !        | 49       | 1        | 65       | A        | 81       | Q        | 97       | a        | 113      | q        |
| **2**    | STX      | 18       | DC2      | 34       | ”        | 50       | 2        | 66       | B        | 82       | R        | 98       | b        | 114      | r        |
| **3**    | ETX      | 19       | DC3      | 35       | #        | 51       | 3        | 67       | C        | 83       | S        | 99       | c        | 115      | s        |
| **4**    | EOT      | 20       | DC4      | 36       | $        | 52       | 4        | 68       | D        | 84       | T        | 100      | d        | 116      | t        |
| **5**    | ENQ      | 21       | NAK      | 37       | %        | 53       | 5        | 69       | E        | 85       | U        | 101      | e        | 117      | u        |
| **6**    | ACK      | 22       | SYN      | 38       | &        | 54       | 6        | 70       | F        | 86       | V        | 102      | f        | 118      | v        |
| **7**    | BEL      | 23       | ETB      | 39       | ’        | 55       | 7        | 71       | G        | 87       | W        | 103      | g        | 119      | w        |
| **8**    | BS       | 24       | CAN      | 40       | (        | 56       | 8        | 72       | H        | 88       | X        | 104      | h        | 120      | x        |
| **9**    | HT       | 25       | EM       | 41       | )        | 57       | 9        | 73       | I        | 89       | Y        | 105      | i        | 121      | y        |
| **10**   | LF       | 26       | SUB      | 42       | *        | 58       | :        | 74       | J        | 90       | Z        | 106      | j        | 122      | z        |
| **11**   | VT       | 27       | ESC      | 43       | +        | 59       | ;        | 75       | K        | 91       | [        | 107      | k        | 123      | {        |
| **12**   | FF       | 28       | FS       | 44       | ,        | 60       | <        | 76       | L        | 92       | \        | 108      | l        | 124      | \|       |
| **13**   | CR       | 29       | GS       | 45       | -        | 61       | =        | 77       | M        | 93       | ]        | 109      | m        | 125      | }        |
| **14**   | SO       | 30       | RS       | 46       | .        | 62       | >        | 78       | N        | 94       | ^        | 110      | n        | 126      | ~        |
| **15**   | S1       | 31       | US       | 47       | /        | 63       | ?        | 79       | O        | 95       | _        | 111      | o        | 127      | DEL      |

有了ASCII码表英文文本的存储就比较简单了，直接将文本中的每个字符转换成对应的ASCII码即可。按照这种格式保存在计算机中的文件被称为文本文件（text file），最常见的文本文件是后缀名为“==.txt==”的文件。

###### 汉字编码

ASCII码解决了英文文本的编码问题，非英文的语言文字的编码问题则需要另想办法，和英文类似由字母构成的语言在文本编码方面处理起来有一定优势，而汉字构成的中文则麻烦许多。常用的汉字有几千个，给每一个汉字设计一个位模式编码是一项很繁琐的工作。
**国家标准化管理委员会（Standardization Administration of China，==SAC==）**在1981年5月1日发布了==《信息交换用汉字编码字符集（基本集）》（简称GB2312）==，现在常说的国标码就是指的这个编码字符集。不过国标码并不是汉字在计算机中保存的编码形式，而且汉字的计算机化也不止存储需要编码，输入输出也需要编码，下面简要介绍这些编码的来龙去脉。

①输入码
计算机键盘上有26个英文字母键，所以英文的输入不需要编码。但是汉字就不一样了，目前键盘依然是主要的输入工具，如何将汉字转换成键盘上的键码是汉字输入要解决的问题，每个汉字都有对应的输入码。
目前最常用的输入码就是汉字对应的汉语拼音，上世纪八九十年代拼音输入法还不成熟时，五笔字型是比较流行的输入码，其它流行过的输入码还有接下来要介绍的==区位码==。

②区位码
区位码是对汉字的一种十进制数字编码，其编码方案是将6763个汉字以及682个其它符号放入一个**94行94列**的表格中，每个汉字或其它符号占据一个单元格。
这6763个汉字中常用的一级汉字有3755个，按拼音顺序分布在表格的第16-55行；不太常用的二级汉字3008个，分布在表格的第56-87行；682个其它符号分布在表格的前9行，其余所在行空置。
对表格中每个符号的编码使用4位十进制数，左边2位数对应其所在行，右边2位数对应其所在列；比如第1行第9列的符号‘々’对应区位码是0109，计算思维的‘计’字对应的区位码是2838，所以它位于第28行38列。汉字与区位码的双向查询可以查阅区位码表，不过也很容易在互联网上在线查询。

③国标码
区位码是十进制编码，如果要转换成计算机存储的位模式编码，第一步就是由区位码转换成国标码。国标码就是前面提到的我国在1981年发布的GB2312，具体转换方式是将区位码前两位数和后两位数分别转换成十六进制数，然后再分别加上==$(20)_{16}$==后再合在一起就构成了**国标码（十六进制表示形式）**，所以国标码采取的是2个字节（16位）的存储容量。

**例17 ‘计’字的区位码是2838，求其对应的国标码。**
**[解] 区位码的前两位数$28=(1c)_{16}$，$(1c)_{16}+(20)_{16}=(3c)_{16}$；**
**区位码的后两位数$38=(26)_{16}$，$(26)_{16}+(20)_{16}=(46)_{16}$；**
**则‘计’字的国标码是$(3c46)_{16}$。**

④机内码
ASCII码表中每个字符虽然占据1个字节，但是其位模式编码的最高位都是0，所以出于兼容ASCII码的考虑，将汉字国标码的两个字节中每个字节的**最高位都设置为1**，就不会在解码上与ASCII码出现二义性了。
**例18 ‘计’字的国标码是0011 1100 0100 0110，求其对应的机内码。**
**[解] ‘计’字的国标码0011 1100  0100 0110，将其前一个字节00111100的最高位改成1变成10111100，后一个字节01000110的最高位改成1变成11000110，再合在一起构成的位模式1011 1100 1100 0110，即为‘计’字存储在计算机中的机内码形式。**
**不过有一个问题可以深入思考下，有没有可能出现某个汉字国标码的2个字节最高位都是1，而不需要将其转换成机内码的情况？**

⑤字型码
汉字字型码用于汉字的输出，通常有点阵和矢量两种表示方式。
使用点阵表示的字型也称为字模，简易型汉字为$16\times16$点阵，提高型汉字为$24\times24$点阵以及$32\times32$点阵等。

下图给出了‘中’字的字模及其对应的字型码，该字模使用了$16\times16$点阵，涂黑的小方格描出了‘中’字的字型，点阵中白格用0表示，黑格用1表示，将$16\times16$的方格转换成了16行16位的位模式，构成了‘中’字的字型码。

![](https://github.com/Wishforpeace/Typora/blob/ba437fb4bf5c0bb4fb1133b9652193e3c080a743/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E5%AD%97%E5%9E%8B%E7%A0%81.png)

**矢量表示方式存储的是描述汉字字型的轮廓特征**，当要输出汉字时，通过计算机的计算，由汉字字型描述生成所需大小和形状的汉字点阵。矢量化字型描述与最终文字显示的大小，分辨率无关，因此可以产生高质量的汉字输出。Windows中使用的TrueType技术就是汉字的矢量表示方式。
国标码GB2312中只包含简体字，1984年台湾发布实施了《台湾地区繁体中文标准字符集》（该编码最初为五大中文套装软件设计，所以简称为BIG5），采用双字节编码，共收录13053个中文字；我国在1995年12月发布了GB2312的扩充版本GBK，收录21003个汉字，也包含BIG5中的所有繁体字。2000年3月再次发布了GBK的扩充版本GB18030，其中收录27484个汉字，还包括中国少数民族文字以及日本和朝鲜文字，采用单字节、双字节和四字节三种方式对字符编码，兼容ASCII、GB2312和GBK。

###### UNICODE与UCS

==国际非盈利组织统一码联盟==（the Unicode Consortium）在上世纪90年代初期发布的==UNICODE（万国码）==，为每种语言中的每个字符设定了统一并且唯一的编码，以满足跨语言、跨平台进行文本转换、处理的要求。统一码联盟提出的UNICODE标准中给出了收录的字符信息，并不包括这些字符的存储方法，针对UNICODE字符存储的编码实现方案目前常用的有UTF8、UTF16、UTF32。
==国际标转化组织（International Organization for Standardization，ISO）==出于统一全球字符集的考虑也发布了一种被称为==基于通用字符集（Universal Character Set，UCS）==的字符集，其对应的编码实现方案有==UCS2和UCS4。==
UNICODE与UCS两者早在发布初期已经有了互相兼容的意识，目前两者正在携手发展。

##### 音频的存储

声音是由物体振动产生的波动现象，它通过空气、液体或固体等介质的传播并能被人和动物的听觉器官所感知。最初发出振动的物体叫声源，声音以波的振动形式传播，频率在20 Hz~20 kHz之间的声音是可以被人耳识别的。人能够识别的声音也称为音频（audio）。音频存储到计算机中通常需要经过采样（sampling）、量化（quantization）、编码（encoding）三个步骤。

###### （1）采样

声波是一种模拟信号，将随时间连续变化的声波的振幅，按一定时间间隔采集样值，从而形成在时间上不连续的脉冲序列，这一过程被称为采样。对声波的采样是不断进行的，每隔一段时间就进行一次采样，**单位时间对声波的采样次数被称为采样频率（sampling frequency），采样频率越高越能捕捉到声波的细微变化。**

###### （2）量化

采样之后得到数量相当大的采样值，这些采样值不可能恰好都是整数，所以需要使用一定的转换和取舍将这些**采样值全部转换成整数**，因为整数的编码过程比小数的编码过程简单许多。在采用这种四舍五入的方法量化后，*相比原声波信号产生了一定程度的误差，当这种误差值小到一定程度时，人耳也不能加以辨别。*

###### （3）编码

音频的编码则是将量化后的**样本值表示成位模式**，通常量化后的值如果是非负整数，则采用无符号表示法给样本值编码；量化后的值如果正负整数都包含，则采用符号加绝值表示法给样本值编码；对每个采样值的编码长度被称为采样位数，采样的频率越高，采样位数也越多。
目前主流的音频格式是MP3，它采用每秒44100个样本的采样频率，采样位数是16位。

##### 图像的存储

计算机能够存储和处理的图片主要有2类：**==矢量图（vector graphic）和位图（bitmap）==**。矢量图形使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。
图像可以看做是各种各样的色彩组成的五彩斑斓的画卷。为了记录下构成图片的所有色彩，可以将图像按照行和列分成若干小方格，分的越细，每个小方格中包含的色彩就越接近，直到最后每个小方格缩小成肉眼所见的单一颜色的点，然后将所有点的颜色量化（和音频的量化类似），最后再对所有点的颜色值编码，就得到了图像的数字化存储格式，这种格式的图像被称为位图（后缀名为“.bmp”）。

将图像输入到计算机中通常要借助于专门的设备，比如扫描仪和数码相机等。扫描仪扫描一张图片的过程实际上就是一个将图像进行编码并存储的过程。
将图像分成小方格的细密程度使用**分辨率（resolution ratio）**来衡量，比如将图像的行800等分，列600等分，被分成480000个小格子，其中每个小格子被称为一个**像素（pixel）**，对应的分辨率就用$800\times600$表示，分的像素越多分辨率就越高，按照存储格式还原输出后的图像的质量就越好。
图像的输出质量除了取决于分辨率的大小，还取决于颜色值的细化程度，每一种颜色也是由深到浅连续变化的，对同一种颜色，使用不同的数描述不同深浅程度的颜色值，就是对颜色进行量化，对颜色由深到浅的变化程度分的越细，图像的输出质量也越高。

将颜色数字化的方法有很多，其中最常用的是**真彩色（true color）**。所有的颜色都可以由**红、绿、蓝**这三种颜色按照一定比例调和而成，红、绿、蓝这三种颜色也称为**三基色（three primary colours）**，将每一种基色按照深浅程度划分为256各等级，分别使用数字0-255表示，比如0级红色表示最浅的红色（实际上就是白色），255级红色表示最深的红色（鲜红），使用三元组（r,g,b）则可以表示任意颜色，其中r表示红色的颜色值，g表示绿色的颜色值，b表示蓝色的颜色值。**三元组中每个分量256个值，所以使用二进制编码需要8位（28=256），那么表示三个分量一共需要24位，也就是说每个像素对应的颜色值需要使用24位位模式表示。**
位图图像占据的存储容量比文本大，当前计算机处理图片时都会进行压缩，目前常见的视频压缩格式有jpeg和jpg等。

##### 视频的存储

视频（video）是图像在时间上的表示，一部视频就是一系列的图像一张接一张地播放而形成的运动画面，其中每张图像称为该视频的**一个帧（frame）**。
因此对视频的存储是建立在图像存储的基础之上的。由于一部视频包含成千上万的帧，因此保存视频的信息量相当巨大，通常将**视频转换成二进制格式之后都要进行压缩来节省空间**，目前常见的视频压缩格式有mpeg4、rmvb、mkv、avi等。

## 4.程序设计概念

### 计算机硬件的核心组成部分

+ CPU
+ Inout/Output
+ Memory

#### 中央处理单元(Central Processing Unit,CPU)![](https://github.com/Wishforpeace/Typora/blob/main/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/image-20211227152147372.png)



ALU:算术逻辑单元，处理程序运行时的算术运算与逻辑运算

R：数据寄存器，保存程序运行时处理的运算数据

I：指令寄存器，保存程序运行时的每一条机器指令

PC：程序计数器，保存程序运行时的每一条机器指令在内存中的地址

Control Unit：控制单元，实现对CPU从内存中读取指令、翻译指令、执行指令的操作控制

#### 内存（Memory，有时称为主存）

![](https://github.com/Wishforpeace/Typora/blob/main/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/image-20211227152531536.png)

#### 内存可以保存的数据形式为全部由0或1组成的位模式（0或1组成的数字串），8位构成1个字节，是最小的数据存储单位，每个字节会被分配一个编号（也就是常说的内存地址），在计算机系统中，内存地址使用二进制形式表示。

### 输入输出系统（Input Output System，简称IOS）

![](https://github.com/Wishforpeace/Typora/blob/main/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/image-20211227152721690.png)

计算机系统最典型的输入设备包括键盘和鼠标，最典型的输出设备是显示器。其它常用设备如硬盘和光驱（较早计算机系统还有软驱）则既是输入设备也是输出设备。
程序在计算机上执行前先保存在硬盘（或U盘、光盘、软盘）中，程序开始执行时，操作系统会将程序装入内存中，保存到内存中的程序由若干条CPU可识别的机器指令构成，CPU中的控制单元从内存中==读取指令、翻译指令、执行指令==，然后重复这个过程直到程序执行结束。
CPU进行一次==读取指令、翻译指令、执行指令的过程被称为指令周期==，单位时间内执行的指令周期数量被称为==CPU的频率==。
程序在执行过程中有时需要使用程序的用户输入数据，这时用户通过输入设备将数据输入到内存中，然后CPU再从内存中读取数据进行后续操作，程序运行结果先保存到内存中，再由内存转移到输出设备上。

### 计算机程序设计语言的发展

+ #### 机器语言

  >机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能，机器语言编写的程序等于直接向CPU发指令， CPU可以直接处理和执行机器指令。

+ #### 汇编语言

  >为了减轻机器语言带给程序员的不适应，人们对机器语言进行了升级和改进：用一些容易理解和记忆的单词来代替特定的指令。通过这种方法，人们很容易去阅读程序或者理解程序正在执行的功能，对现有程序的修改和维护都变得更加简单方便，这种语言就是我们所说的汇编语言。
  >由于汇编语言使用了人类熟悉的助记符，计算机无法像机器语言编写的程序一样直接识别和执行，必须把汇编语言转换成能够被计算机识别和处理的机器语言。

+ #### 高级语言

  >使用机器语言和汇编语言进行程序设计时，要求使用者必须了解计算机的硬件结构，而不同型号的计算机硬件结构是不一样的，这极不利于程序在不同型号计算机上的推广。
  >随着计算机技术的发展，计算机科学家开发出接近自然语言且与具体硬件结构无关的程序设计语言，使用这些语言编写程序可以不需要了解计算机的硬件细节，这样的程序设计语言被称为高级程序设计语言，简称为高级语言。典型代表有：Fortran、Pascal、C、C++、Java、Python等。
  >高级语言也分为结构化程序设计语言与面向对象的程序设计语言， Fortran、Pascal、C 是结构化程序设计语言， C++、Java、Python 是面向对象的程序设计语言。

  #### 编译与解释

+ 高级语言编写的程序也被称为==源程序或源代码==，需要经过转换成==机器语言==编写的程序后才能被计算机执行，转换过程有**编译**与**解释**两种。

+ ==两者的区别在于==，

  + 编译是一次性将高级语言编写的程序全部转换成机器语言编写的程序后再执行，
  + 解释则是将高级语言编写的程序逐条转换成机器语言编写的程序，每转换一条后就执行一条。

实现**编译功能**的程序被称为==编译器==，实现**解释功能**的程序被称为==解释器==。
常用的高级语言中，C和C++是编译型语言，Python是解释性语言。Java即是编译性也是解释性语言。
源程序(或源代码)转换后的机器可执行的程序也被称为目标程序或目标代码，计算机可执行的程序保存在后缀名为“exe”的文件中，所以后缀名为“exe”的文件也被称为可执行文件。

## 5.算法简介

### 算法特征 

+ 有限性（有穷性）
+ 确定性
+ 输入
+ 输出
+ 能行性

### 机器学习算法简介

>机器学习的研究最早可以追溯到1952 年，IBM科学家Arthur Samuel设计了一款可以学习的西洋跳棋程序。它能通过观察棋子的走位来构建新的模型，并用其提高自己的下棋技巧。Samuel和这个程序进行多场对弈后发现，随着时间的推移程序的棋艺变得越来越好。Samuel用这个程序推翻了以往“机器无法超越人类，不能像人一样写代码和学习”这一传统认识，他对机器学习的定义是：==不需要确定性编程就可以赋予机器某项技能的研究领域。==

#### 机器学习算法分为两大类：

##### 监督学习：

> 监督学习是指学习数据本身被进行了**==人工标注==**，算法利用数据训练模型，然后用模型预测那些没有标注的数据，给出预测结果。例如，利用已经人工标注好猫和狗的图片各1000张，训练一个模型，可以让计算机识别没有见过的新图片，判断它是猫还是狗。

监督学习分为：

###### 回归问题：

> 回归问题指的是预测结果为==连续值==的问题，如线性回归、股票价格预测、天气预报等。

###### 分类问题：

>分类问题指的是预测结果为==离散值==的问题，如图片分类、人脸识别、神经网络分类等。目前流行的神经网络算法因其网络层次较多，也被称为==深度学习算法==。有一种解决分类问题的算法叫做==逻辑斯蒂回归算法==，虽然名字中有回归，它实际上是一种分类算法。

**监督学习算法使用人工标注好的数据得到模型的过程称为==训练==，用模型再去对没有人工标注的数据进行分类或回归值的过程称为==预测==。监督学习算法处理的数据又通常被分成==训练集和测试集==，==训练集==用于==构建==模型，==测试集==用于==测试==模型的效率。**

##### 无监督学习：

> 无监督学习是指学习数据本身是**==没有人工标注==**的，算法根据数据本身的特点给出预测结果。例如有猫狗图片各1000张，但并没有标明哪些是猫哪些是狗，让计算机自动把这些图片分成两类。

###### 聚类问题：

> 使用无监督学习算法解决的问题中最典型的是聚类问题，它可以简单地描述为：根据在数据中发现的描述对象及其关系的信息，将数据对象分组。下图是聚类问题的一个实例，左上角子图中黑点表示没有被人工标记的对象，其余三个子图为执行不同聚类算法之后的分类结果，相同颜色与形状的点被划分为一类。

![](https://github.com/Wishforpeace/Typora/blob/main/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E5%9B%BE%E7%89%871.png)

### 查找算法

#### 顺序查找

顺序查找的基本思想是：
从列表的起始位置开始扫描，依次将扫描到的元素值与待查找的元素值相比较，若找到相等的则表示查找成功并输出该元素在列表中的位置（可以输出该元素在列表中的下标，如果列表中有多个元素值与待查找的元素值相等，则输出位置最靠前的元素的下标）；
若扫描结束仍没有找到与待查找的元素值相等的元素，则表示查找失败（通常输出一个负整数如-1表示查找失败）。

输入一个整数，输出其在列表[1, 2, 32, 8, 17, 19, 42, 13, 0]中的位置（下标），如果该数不在列表中，则输出-1。
实现顺序查找的python代码如下：

```python
a=[1, 2, 32, 8, 17, 19, 42, 13, 0]
n=len(a)
x=int(input("输入一个整数x="))
posi=-1  #变量posi表示x在列表a中的位置，默认其不在a中
for i in range(n):
    if x==a[i]:
        posi=i
print(posi)

```



#### 二分查找

二分查找也叫做折半查找，也是查找某个元素在列表中的位置，不过二分查找针对的列表是有序表，列表元素值按照递增或递减顺序排列。二分查找的基本思想是：
查找过程从列表的中间元素开始，用待查找元素x先与列表最中间的元素m比较，m将列表分成两个子表，若x与m相等则查找成功；
若x小于m，则在前一个字表中继续查找x；
若x不小于m，则在后一个字表中继续查找x；进一步查找过程重复刚开始的步骤，递归进行下去，直到找到x在列表中的位置，或者发现x并不在列表中。

实现二分查找的python代码如下：

```python
a = [10,14,21,38,45,47,53,81,87,99]
x=int(input("请输入要查找的整数x="))  #注意末尾有两个反括号
left=0  #left的初值是列表中第一个数的下标
right=len(a)-1  #left的初值是列表中最后一个数的下标
while left<=right:    
    middle=(left+right)//2  #'//'是除法取整运算符
    if a[middle]<x:
        left=middle+1        
    elif a[middle]==x :  #在python中等号用'=='表示
        print('查找成功！',x,'是列表中的第',middle+1,'个数！')
        break  #循环异常终止    
    else:  #a[middle]>x
        right=middle-1        
else:  #循环正常终止
    print('查找失败！')
```

#### 排序算法

###### （1）冒泡排序

冒泡排序（以递增排序为例）的基本思想是：
从第一个元素开始，依次比较相邻两元素，如果前一元素大于后一元素就交换位置，否则不作处理，直到最后一个元素为最大，此时完成第一次循环；
然后重新从新的首元素开始，再次依次比较相邻两元素，直至倒数第二个元素为次大元素，完成第二次循环；以此类推，直至没有任何一对数字需要比较，则此序列最终成为有序序列。
当两元素的交换条件为：前一元素小于后一元素时交换位置，此排序方式就转变为从大到小排序。

实现冒泡排序的Python程序

```python
a = [6, 3, 5, 7, 0]
n = len(a)
for i in range(n-1,0,-1):  #每次外层循环对a[0]至a[i]实施一趟交换操作
    for j in range(0, i):  #每次里层循环对a[j]与a[j+1]进行比较
        if a[j] > a[j+1]:  #每次比较相邻两元素时
                                  #如果前一个大，就对两者进行交换
            t=a[j]
            a[j]=a[j+1]
            a[j+1]=t
print(a)
```

![](https://github.com/Wishforpeace/Typora/blob/9670b6031027b4cbdc88f4176145bf18c427bc70/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png)

###### （2）插入排序

插入排序的基本思想是：将n个待排序的元素看成一个有序列表和一个无序列表，开始时从n个待排序元素中抽取一个元素作为有序列表，则剩余的n-1个元素组成无序列表，每次抽取无序列表中的一个元素插入到有序列表中，直到无序列表中的所有元素都插入到有序列表中。

![](https://github.com/Wishforpeace/Typora/blob/9670b6031027b4cbdc88f4176145bf18c427bc70/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png)

```python
def insertSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex >=0 and arr[preIndex] > current:
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        arr[preIndex+1] = current
    return arr
array = [3,5,2,15,36,7,30,50,22]
print(insertSort(array))
```

###### (3)选择排序

选择排序（以递增排序为例）的基本思想是：从n个待排序元素中选出最小的一个元素，放在数列的第1位；接着从后n-1个待排序元素中选出最小元素，放在数列的第2位；反复执行此操作，直到全部待排序的数据元素排完。

![](https://github.com/Wishforpeace/Typora/blob/9670b6031027b4cbdc88f4176145bf18c427bc70/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png)

```python
def insertSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex >=0 and arr[preIndex] > current:
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        arr[preIndex+1] = current
    return arr
array = [3,5,2,15,36,7,30,50,22]
print(insertSort(array))
```

## 6.流程图

结构化程序设计中的三种基本程序结构为顺序结构、选择结构、循环结构。
流程图是表示程序结构的一种图形工具，其基本组成部分如右图所示。
起止框：每个流程图都有一个开始框和结束框；
输入输出框：对应输入输出语句；
处理框：对应赋值语句；
判断框：对应选择或循环时的判断条件；
流程线：对应语句执行的先后顺序。

![](https://github.com/Wishforpeace/Typora/blob/6940f866906b96a6a18c46eef6ca6762709e56cf/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

## 7.计算机网络

### 互联网起源

1969 年美国国防部创建的==ARPANET== 最初只是一个单个的分组交换网（并不是一个互连的网络）。所有要连接在ARPANET 上的主机都直接与就近的结点交换机相连。
但到了20 世纪70 年代中期，人们己认识到不可能仅使用一个单独的网络来满足所有的通信问题。于是ARPANET开始研究多种网络（如分组无线电网络）互连的技术，这就导致了互连网络的出现。这就成为 现今互联网的雏形。
ARPANET也被公认为世界上的第一个计算机网络。

### 相关概念

#### （1）报文与分组

在网络中数据通常由一台主机传输到其它主机，把要发送的整块数据称为一个报文。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，在每一个数据段前面，加上一些由必要的控制信息组成的首部后，就构成了一个分组。

![](https://github.com/Wishforpeace/Typora/blob/da7d72931f25670d2fcd73efecd275c8f502d707/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E6%8A%A5%E6%96%87%E4%B8%8E%E5%88%86%E7%BB%84.png)

#### （2）传输速率

计算机能够存储的数据中，==单个数字0或1被称为位（bit）==，因为bit直译可读作比特，所以有时位也被称为比特位，比特位是计算机系统中最小的存储单位，==8个比特位被称为字节（byte）==。
光纤等当前主要的网络传播介质中传输的也是由0或1表示的数字信号，衡量网络传输数据快慢的指标为传输速率，其单位为bit/s，表示每秒钟传输的比特位数量，也可以简写为b/s。
随着信息技术的飞速发展，传输速率如果以bit/s为单位表示将是一个相当巨大的数，因此引入一些字母表示较大的数量，常用的表示数量的字母有K、M(兆)、G(不区分大小写)，如果是表示网络传输数量时，它们表示的数量为：$1K=1000=10^3$，$1M=1000K=10^6$，$1G=1000M=10^9$。
如果是在表示存储容量时，K、M、G三者之间的关系是$1K=1024=2^{10}$，$1M=210K=2^{20}$，$1G=210M=2^{30}$，注意结合上下文区分。

传输速率的单位通常为bit/s，也就是每秒钟传输的比特位数量，有的时候传输速率的单位也使用byte/s，也就是使用每秒钟传输的字节数量作为的传输速率度量。
bit/s通常也可以更为简化地表示为b/s，为了以示区别，通常byte/s使用更为简化地表示方式为B/s，因为1byte=8bit，所以1B/s=8b/s。
有时表示传输速率的数据中心还会出现前面提到的表示较大数量的字母K、M、G等，它们与b和B混在一起要注意区分，例如：
$2Mb/s$表示传输速率为$2000000$个比特位/每秒
$2MB/s$表示传输速率为$2000000$个字节/每秒
$2MB/s=(2M\times8)b/s=16Mb/s=16000000b/s$
以$1.6Mb/s$的速率传输$1000K$个字节所花的时间为：

![](https://github.com/Wishforpeace/Typora/blob/ce1a75e4bf22b4bb6e52ec39d9e799a00fade362/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%88%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%89/%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87.png)

#### （3）时延

时延是指数据（一个报文或分组）从网络的一端传送到另一端所需的时间，它由以下几个不同的部分组成：
==1）发送时延==，可以简单地理解为网络一端的节点**将自己主机上的数据发送到通信链路上**所用的时间，发送时延=数据长度/传输速率；
传输速率指的是**单位时间内主机向链路发送的数据长度**；
==2）传播时延==，是指数据在通信链路中传播一定的**距离**需要花费的时间，传播时延=传播距离/传播速率；传播速率指的是单位时间内数据在链路中的传播距离，和前面提到的传输速率不是一个概念；
==3）处理时延==， 节点在收到数据时要花费的处理时间；
==4）排队时延==，数据在经过网络传输时，进入各个路由器后在输入或输出队列中排队等待处理的时间。
**时延=发送时延+传播时延+处理时延+排队时延**

#### （4）带宽

网络中两个节点（可以简单地理解为连接到网络中的计算机）之间的**物理通道**称为==通信链路（简称为链路）==，其**传输介质（连接节点的网线材料）主要有双绞线、同轴电缆以及光纤**等，数据在不同介质中传输的速率是不同的，**通常将带宽作为计算机网络中中数据传输能力的度量指标**。
带宽的应用领域非常多，不同的领域带宽表示的含义也不同。在计算机网络中，带宽指的是在单位时间内链路所能通过的最大数据量，带宽的单位也是b/s或B/s，**带宽也可以简单地理解为主机向链路发送数据时能够获得的最大传输速率。**

**下面看一个计算发送时延和传播时延的例子。**
收发两端之间的传输距离为$1000 km$（千米），数据（信号）在链路上的传播速率为$2\times10^8m/s$（米/秒），数据长度为$10^7bit$，数据发送时的传输速率为$100kbit/s$，计算发送时延和传播时延。
在计算传播时延时，需要厘清地是传输速率与传播速率的度量角度是不同的，前者度量的是单位时间内可以传输多少数据量，后者度量的则是单位时间内数据可以传播多远。
根据前面介绍的公式：
$传播时延= 1000 km/(2\times10^8m/s)=1000000m/(2\times10^8m/s)=0.005s=0.005秒$
$发送时延= 10^7bit/(100kbit/s)=(10^7/100k)s=(10000000/100000)=100s=100秒$
课堂思考：有一条链路长$100km$，若数据在此链路上的传播速度为$4\times10^6m/s$，请问链路的带宽至少应为多大才能使传播时延与发送$1000$个字节分组的发送时延一样大？

#### （5）开放系统互联模型与网络协议

**国际标准化组织（ISO）**为了规范协议层次的划分制定了**开放系统互联（OSI，Open Systems Interconnection）模型**，即**ISO/OSI**参考模型。此模型根据网络功能制定出**7层网络协议结构**，由低到高分别为**物理层、数据链路层、网络层、传输层、会话层、表示层和应用层**。
网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：**语法、语义、时序**。
从ARPANET网络研发并一直沿用至今的互联网基础通信协议为**TCP/IP**协议，它是由**FTP、SMTP、TCP、UDP、IP等协议构成的协议簇**。
